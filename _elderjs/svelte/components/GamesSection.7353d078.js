import { n as noop, s as safe_not_equal, R as is_function, T as subscribe, U as run_all, J as create_component, k as space, e as element, K as claim_component, l as claim_space, c as claim_element, a as children, d as detach_dev, b as attr_dev, f as add_location, L as mount_component, i as insert_dev, q as transition_in, r as transition_out, M as destroy_component, h as dispatch_dev, v as validate_slots, V as validate_store, W as component_subscribe, X as setContext, Y as set_store_value, S as SvelteComponentDev, j as init } from '../index-96466d9a.js';
import { t as tagsFilter } from '../tagsFilter-23b6c8d4.js';
import GameList from './GameList.f1d03ab5.js';
import './Tag.4a56e822.js';
import Tags from './Tags.7fe25aaf.js';
import './GameTeaser.a00773f6.js';
import SearchGames from './SearchGames.cb64d968.js';

const subscriber_queue = [];
/**
 * Creates a `Readable` store that allows reading by subscription.
 * @param value initial value
 * @param {StartStopNotifier}start start and stop notifications for subscriptions
 */
function readable(value, start) {
    return {
        subscribe: writable(value, start).subscribe
    };
}
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = [];
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (let i = 0; i < subscribers.length; i += 1) {
                    const s = subscribers[i];
                    s[1]();
                    subscriber_queue.push(s, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            const index = subscribers.indexOf(subscriber);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
            if (subscribers.length === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}
function derived(stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single
        ? [stores]
        : stores;
    const auto = fn.length < 2;
    return readable(initial_value, (set) => {
        let inited = false;
        const values = [];
        let pending = 0;
        let cleanup = noop;
        const sync = () => {
            if (pending) {
                return;
            }
            cleanup();
            const result = fn(single ? values[0] : values, set);
            if (auto) {
                set(result);
            }
            else {
                cleanup = is_function(result) ? result : noop;
            }
        };
        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
            values[i] = value;
            pending &= ~(1 << i);
            if (inited) {
                sync();
            }
        }, () => {
            pending |= (1 << i);
        }));
        inited = true;
        sync();
        return function stop() {
            run_all(unsubscribers);
            cleanup();
        };
    });
}

/* src/components/GamesSection.svelte generated by Svelte v3.29.7 */
const file = "src/components/GamesSection.svelte";

function create_fragment(ctx) {
	let searchgames;
	let t0;
	let div0;
	let t1;
	let tags;
	let t2;
	let div1;
	let t3;
	let gamelist;
	let current;

	searchgames = new SearchGames({
			props: {
				allGames: /*allGames*/ ctx[0],
				tagsFilter: /*$tagsFilter*/ ctx[2]
			},
			$$inline: true
		});

	searchgames.$on("update", /*updateGameList*/ ctx[5]);

	tags = new Tags({
			props: { tags: [.../*allTags*/ ctx[3]] },
			$$inline: true
		});

	gamelist = new GameList({
			props: { games: /*gamesList*/ ctx[1] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(searchgames.$$.fragment);
			t0 = space();
			div0 = element("div");
			t1 = space();
			create_component(tags.$$.fragment);
			t2 = space();
			div1 = element("div");
			t3 = space();
			create_component(gamelist.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			claim_component(searchgames.$$.fragment, nodes);
			t0 = claim_space(nodes);
			div0 = claim_element(nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(tags.$$.fragment, nodes);
			t2 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true });
			children(div1).forEach(detach_dev);
			t3 = claim_space(nodes);
			claim_component(gamelist.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "spacing-small svelte-1w0xbv1");
			add_location(div0, file, 57, 0, 1136);
			attr_dev(div1, "class", "spacing-large svelte-1w0xbv1");
			add_location(div1, file, 61, 0, 1197);
		},
		m: function mount(target, anchor) {
			mount_component(searchgames, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div0, anchor);
			insert_dev(target, t1, anchor);
			mount_component(tags, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, div1, anchor);
			insert_dev(target, t3, anchor);
			mount_component(gamelist, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const searchgames_changes = {};
			if (dirty & /*allGames*/ 1) searchgames_changes.allGames = /*allGames*/ ctx[0];
			if (dirty & /*$tagsFilter*/ 4) searchgames_changes.tagsFilter = /*$tagsFilter*/ ctx[2];
			searchgames.$set(searchgames_changes);
			const gamelist_changes = {};
			if (dirty & /*gamesList*/ 2) gamelist_changes.games = /*gamesList*/ ctx[1];
			gamelist.$set(gamelist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(searchgames.$$.fragment, local);
			transition_in(tags.$$.fragment, local);
			transition_in(gamelist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(searchgames.$$.fragment, local);
			transition_out(tags.$$.fragment, local);
			transition_out(gamelist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(searchgames, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t1);
			destroy_component(tags, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div1);
			if (detaching) detach_dev(t3);
			destroy_component(gamelist, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $tagsFilter;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GamesSection", slots, []);
	let { allGames } = $$props;

	// List all tags
	const allTags = allGames.reduce(
		(acc, current) => {
			current.tags.forEach(tag => {
				acc.add(tag);
			});

			return acc;
		},
		new Set()
	);

	// Tags filter logic
	const tagsFilter$1 = writable([]);

	validate_store(tagsFilter$1, "tagsFilter");
	component_subscribe($$self, tagsFilter$1, value => $$invalidate(2, $tagsFilter = value));

	setContext(tagsFilter.key, {
		toggleTag: tag => {
			if ($tagsFilter.includes(tag)) {
				set_store_value(tagsFilter$1, $tagsFilter = $tagsFilter.filter(i => i !== tag), $tagsFilter);
				return;
			}

			set_store_value(tagsFilter$1, $tagsFilter = [...$tagsFilter, tag], $tagsFilter);
		}
	});

	// Game list logic
	let gamesList = allGames;

	const updateGameList = event => {
		$$invalidate(1, gamesList = event.detail);
	};

	const writable_props = ["allGames"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GamesSection> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("allGames" in $$props) $$invalidate(0, allGames = $$props.allGames);
	};

	$$self.$capture_state = () => ({
		setContext,
		writable,
		key: tagsFilter.key,
		GameList,
		SearchGames,
		Tags,
		allGames,
		allTags,
		tagsFilter: tagsFilter$1,
		gamesList,
		updateGameList,
		$tagsFilter
	});

	$$self.$inject_state = $$props => {
		if ("allGames" in $$props) $$invalidate(0, allGames = $$props.allGames);
		if ("gamesList" in $$props) $$invalidate(1, gamesList = $$props.gamesList);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [allGames, gamesList, $tagsFilter, allTags, tagsFilter$1, updateGameList];
}

class GamesSection extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { allGames: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GamesSection",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*allGames*/ ctx[0] === undefined && !("allGames" in props)) {
			console.warn("<GamesSection> was created without expected prop 'allGames'");
		}
	}

	get allGames() {
		throw new Error("<GamesSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set allGames(value) {
		throw new Error("<GamesSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default GamesSection;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2FtZXNTZWN0aW9uLjczNTNkMDc4LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3N0b3JlL2luZGV4Lm1qcyIsIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0dhbWVzU2VjdGlvbi5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbm9vcCwgc2FmZV9ub3RfZXF1YWwsIHN1YnNjcmliZSwgcnVuX2FsbCwgaXNfZnVuY3Rpb24gfSBmcm9tICcuLi9pbnRlcm5hbCc7XG5leHBvcnQgeyBnZXRfc3RvcmVfdmFsdWUgYXMgZ2V0IH0gZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG5jb25zdCBzdWJzY3JpYmVyX3F1ZXVlID0gW107XG4vKipcbiAqIENyZWF0ZXMgYSBgUmVhZGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxuICogQHBhcmFtIHZhbHVlIGluaXRpYWwgdmFsdWVcbiAqIEBwYXJhbSB7U3RhcnRTdG9wTm90aWZpZXJ9c3RhcnQgc3RhcnQgYW5kIHN0b3Agbm90aWZpY2F0aW9ucyBmb3Igc3Vic2NyaXB0aW9uc1xuICovXG5mdW5jdGlvbiByZWFkYWJsZSh2YWx1ZSwgc3RhcnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmU6IHdyaXRhYmxlKHZhbHVlLCBzdGFydCkuc3Vic2NyaWJlXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgYFdyaXRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyBib3RoIHVwZGF0aW5nIGFuZCByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi5cbiAqIEBwYXJhbSB7Kj19dmFsdWUgaW5pdGlhbCB2YWx1ZVxuICogQHBhcmFtIHtTdGFydFN0b3BOb3RpZmllcj19c3RhcnQgc3RhcnQgYW5kIHN0b3Agbm90aWZpY2F0aW9ucyBmb3Igc3Vic2NyaXB0aW9uc1xuICovXG5mdW5jdGlvbiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQgPSBub29wKSB7XG4gICAgbGV0IHN0b3A7XG4gICAgY29uc3Qgc3Vic2NyaWJlcnMgPSBbXTtcbiAgICBmdW5jdGlvbiBzZXQobmV3X3ZhbHVlKSB7XG4gICAgICAgIGlmIChzYWZlX25vdF9lcXVhbCh2YWx1ZSwgbmV3X3ZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBuZXdfdmFsdWU7XG4gICAgICAgICAgICBpZiAoc3RvcCkgeyAvLyBzdG9yZSBpcyByZWFkeVxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bl9xdWV1ZSA9ICFzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgc1sxXSgpO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyX3F1ZXVlLnB1c2gocywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVuX3F1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcl9xdWV1ZVtpXVswXShzdWJzY3JpYmVyX3F1ZXVlW2kgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGUoZm4pIHtcbiAgICAgICAgc2V0KGZuKHZhbHVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZShydW4sIGludmFsaWRhdGUgPSBub29wKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSBbcnVuLCBpbnZhbGlkYXRlXTtcbiAgICAgICAgc3Vic2NyaWJlcnMucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgc3RvcCA9IHN0YXJ0KHNldCkgfHwgbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBydW4odmFsdWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIHN0b3AgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzZXQsIHVwZGF0ZSwgc3Vic2NyaWJlIH07XG59XG5mdW5jdGlvbiBkZXJpdmVkKHN0b3JlcywgZm4sIGluaXRpYWxfdmFsdWUpIHtcbiAgICBjb25zdCBzaW5nbGUgPSAhQXJyYXkuaXNBcnJheShzdG9yZXMpO1xuICAgIGNvbnN0IHN0b3Jlc19hcnJheSA9IHNpbmdsZVxuICAgICAgICA/IFtzdG9yZXNdXG4gICAgICAgIDogc3RvcmVzO1xuICAgIGNvbnN0IGF1dG8gPSBmbi5sZW5ndGggPCAyO1xuICAgIHJldHVybiByZWFkYWJsZShpbml0aWFsX3ZhbHVlLCAoc2V0KSA9PiB7XG4gICAgICAgIGxldCBpbml0ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIGxldCBwZW5kaW5nID0gMDtcbiAgICAgICAgbGV0IGNsZWFudXAgPSBub29wO1xuICAgICAgICBjb25zdCBzeW5jID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmbihzaW5nbGUgPyB2YWx1ZXNbMF0gOiB2YWx1ZXMsIHNldCk7XG4gICAgICAgICAgICBpZiAoYXV0bykge1xuICAgICAgICAgICAgICAgIHNldChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYW51cCA9IGlzX2Z1bmN0aW9uKHJlc3VsdCkgPyByZXN1bHQgOiBub29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZXJzID0gc3RvcmVzX2FycmF5Lm1hcCgoc3RvcmUsIGkpID0+IHN1YnNjcmliZShzdG9yZSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHBlbmRpbmcgJj0gfigxIDw8IGkpO1xuICAgICAgICAgICAgaWYgKGluaXRlZCkge1xuICAgICAgICAgICAgICAgIHN5bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgcGVuZGluZyB8PSAoMSA8PCBpKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBpbml0ZWQgPSB0cnVlO1xuICAgICAgICBzeW5jKCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgICAgcnVuX2FsbCh1bnN1YnNjcmliZXJzKTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgZGVyaXZlZCwgcmVhZGFibGUsIHdyaXRhYmxlIH07XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBzZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJ1xuICBpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSdcbiAgaW1wb3J0IHsga2V5IH0gZnJvbSAnLi4vY29udGV4dHMvdGFnc0ZpbHRlcidcbiAgaW1wb3J0IEdhbWVMaXN0IGZyb20gJy4vR2FtZUxpc3Quc3ZlbHRlJ1xuICBpbXBvcnQgU2VhcmNoR2FtZXMgZnJvbSAnLi9TZWFyY2hHYW1lcy5zdmVsdGUnXG4gIGltcG9ydCBUYWdzIGZyb20gJy4vVGFncy5zdmVsdGUnXG5cbiAgZXhwb3J0IGxldCBhbGxHYW1lc1xuXG4gIC8vIExpc3QgYWxsIHRhZ3NcbiAgY29uc3QgYWxsVGFncyA9IGFsbEdhbWVzXG4gICAgLnJlZHVjZSgoYWNjLCBjdXJyZW50KSA9PiB7XG4gICAgICBjdXJyZW50LnRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICAgIGFjYy5hZGQodGFnKVxuICAgICAgfSlcbiAgICAgIHJldHVybiBhY2NcbiAgICB9LCBuZXcgU2V0KCkpXG5cbiAgLy8gVGFncyBmaWx0ZXIgbG9naWNcbiAgY29uc3QgdGFnc0ZpbHRlciA9IHdyaXRhYmxlKFtdKVxuXG4gIHNldENvbnRleHQoa2V5LCB7XG4gICAgdG9nZ2xlVGFnOiAodGFnKSA9PiB7XG4gICAgICBpZiAoJHRhZ3NGaWx0ZXIuaW5jbHVkZXModGFnKSkge1xuICAgICAgICAkdGFnc0ZpbHRlciA9ICR0YWdzRmlsdGVyLmZpbHRlcihpID0+IGkgIT09IHRhZylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgICR0YWdzRmlsdGVyID0gWy4uLiR0YWdzRmlsdGVyLCB0YWddXG4gICAgfSxcbiAgfSlcblxuICAvLyBHYW1lIGxpc3QgbG9naWNcbiAgbGV0IGdhbWVzTGlzdCA9IGFsbEdhbWVzXG5cbiAgY29uc3QgdXBkYXRlR2FtZUxpc3QgPSAoZXZlbnQpID0+IHtcbiAgICBnYW1lc0xpc3QgPSBldmVudC5kZXRhaWxcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgLnNwYWNpbmctc21hbGwge1xuICAgIGhlaWdodDogNHB4O1xuICB9XG5cbiAgLnNwYWNpbmctbGFyZ2Uge1xuICAgIGhlaWdodDogMTZweDtcbiAgfVxuPC9zdHlsZT5cblxuPFNlYXJjaEdhbWVzXG4gIGFsbEdhbWVzPXthbGxHYW1lc31cbiAgdGFnc0ZpbHRlcj17JHRhZ3NGaWx0ZXJ9XG4gIG9uOnVwZGF0ZT17dXBkYXRlR2FtZUxpc3R9XG4vPlxuXG48ZGl2IGNsYXNzPVwic3BhY2luZy1zbWFsbFwiIC8+XG5cbjxUYWdzIHRhZ3M9e1suLi5hbGxUYWdzXX0gLz5cblxuPGRpdiBjbGFzcz1cInNwYWNpbmctbGFyZ2VcIiAvPlxuXG48R2FtZUxpc3RcbiAgZ2FtZXM9e2dhbWVzTGlzdH1cbi8+XG4iXSwibmFtZXMiOlsidGFnc0ZpbHRlciIsImtleSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFHQSxNQUFNLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUNoQyxJQUFJLE9BQU87QUFDWCxRQUFRLFNBQVMsRUFBRSxRQUFRLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLFNBQVM7QUFDbkQsS0FBSyxDQUFDO0FBQ04sQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxHQUFHLElBQUksRUFBRTtBQUN2QyxJQUFJLElBQUksSUFBSSxDQUFDO0FBQ2IsSUFBSSxNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUM7QUFDM0IsSUFBSSxTQUFTLEdBQUcsQ0FBQyxTQUFTLEVBQUU7QUFDNUIsUUFBUSxJQUFJLGNBQWMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLEVBQUU7QUFDOUMsWUFBWSxLQUFLLEdBQUcsU0FBUyxDQUFDO0FBQzlCLFlBQVksSUFBSSxJQUFJLEVBQUU7QUFDdEIsZ0JB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
